#!/usr/bin/python3

from queue import PriorityQueue
import copy

#Credit:
'''
Generate puzzle: https://qqwing.com/generate.html
'''

p = '''..1...7.8
        ...5.....
        .6...35..
        .3.7..68.
        5.78..14.
        .2.......
        7.3..1...
        ........6
        ....28.3.'''


#Takes a board, in the "dot style" generated by the generator I'm using, and
#converts it into a usable thrice-nested format.
def convert_to_board(s):
    board = []
    for line in s.split("\n"):
        row = []
        for c in line.strip():
            if(c == '.'):
                space = [1,2,3,4,5,6,7,8,9]
            else:
                space = [int(c)]
            row.append(space)
        board.append(row)
    return board


def pretty_print_board(b):
    pretty_print_boards([b])

def pretty_print_boards(boards):
    for b in boards:
        print("")
        print("")
        for row in b:
            print(row)


#Takes a board, and returns the set of spaces which are currently SET
def get_illegal_row_set(b, r):
    illegal = []
    for space in b[r]:
        if len(space) == 1:
            illegal.append(space[0])
    return illegal

#Takes a board, and returns the set of spaces which are currently SET
def get_illegal_column_set(b, c):
    illegal = []
    for row in b:
        if(len(row[c]) == 1):
            illegal.append(row[c][0])
    return illegal

#Test if set contains dupes
def contains_duplicates(s):
    return len(set(s)) != len(s)

#Same as above
def get_illegal_zone_set(b, x, y):
    illegal = []
    for i in range(y*3, y*3 + 3):
        for j in range(x*3, x*3 + 3):
            if(len(b[i][j]) == 1):
                illegal.append(b[i][j][0])
    return illegal

#Tests board validity
def is_valid_board(b):
    #rows
    for i in range(9):
        if(contains_duplicates(get_illegal_row_set(b, i))):
            return False

    for i in range(9):
        if(contains_duplicates(get_illegal_column_set(b, i))):
            return False

    for i in range(3):
        for j in range(3):
            if(contains_duplicates(get_illegal_zone_set(b, i, j))):
                return False
    return True

def find_smallest_space(b):
    smallest = 10
    loc = [0, 0]
    for i in range(9):
        for j in range(9):
            if(len(b[i][j]) <= smallest and len(b[i][j]) != 1):
                smallest = len(b[i][j])
                loc = [i, j]
    return loc

def num_smallest_space(b):
    loc = find_smallest_space(b)
    return str(len(b[loc[0]][loc[1]]))

def make_children(b):
    # print(b)
    children = []
    loc = find_smallest_space(b)
    # print("loc " + str(loc))
    # print(b[loc[0]][loc[1]])
    for mark in b[loc[0]][loc[1]]:
        child = copy.deepcopy(b)
        child[loc[0]][loc[1]] = [mark]
        children.append(child)
    # print("made " + str(len(children)))
    return children

def is_solved(b):
    if(not is_valid_board(b)):
        return False

    for row in b:
        for space in row:
            if(len(space) != 1):
                return False
    return True

def rate_board(b):
    filled = 0
    for row in b:
        for space in row:
            if(len(space) == 1):
                filled += 1

    return - (filled * 100 + int(num_smallest_space(b)))


def solve(board):
    #Seed the boards with the starting board
    boards = PriorityQueue()
    boards.put((rate_board(board), board, 0))

    #Iterate over the boards, pulling from the highest rated
    iterations = 0
    max_iterations = 50000
    iter_print = 100

    while not boards.empty():
        t = boards.get()
        # print(t)
        b = t[1]
        # print("Selected from: iteration " + str(t[2]))
        # print(num_smallest_space(b) + " smallest")
        # print("Board check " + str(b[8][8]))
        if(iterations%iter_print == 0):
            print("iteration: " + str(iterations))
            print(str(rate_board(b)) + " rating")
            print("")

        iterations += 1

        #End early, if we overmax
        if(iterations > max_iterations):
            print("MAX ITERATIONS REACHED")
            return b

        #End early if we found a board!
        if(is_solved(b)):
            print("SOLVED")
            return b

        #Only make new children if the board is valid
        if(is_valid_board):
            children = make_children(copy.deepcopy(b))
            # print("Board rating: " + str(rate_board(b)))
            for child in children:
                # print("Child check " + str(child[8][8]))
                # print("Child rating: " + str(rate_board(child)))
                # print("Child lowest num: " + num_smallest_space(child))
                if(is_valid_board(child)):
                    boards.put((rate_board(child), child, iterations))
        else:
            print("NOT VALID with: " + str(rate_board(child) + " solved"))

b = convert_to_board(p)


print(solve(b))
# pretty_print_boards(make_children(b))





























#bottom
